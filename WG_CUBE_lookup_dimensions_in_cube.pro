601,100
602,"WG_CUBE_lookup_dimensions_in_cube"
562,"NULL"
586,
585,
564,
565,"fh3hxoaa=`8sXOG:ARV[Mwhr\L=cntAQHth0hzLxsUO:AN5zL^\eM15`IT^KGm:?irPRS2\fvOgexw^cBSPtIYNn1vqoH:J6cN0^BbKAS2tptFt]2=pGO`Jl=NUzk4\YFdNjA7Wd[mvW>L[o<^sHGK6=\GnER?NYntuVWU]H`>6id\ct0^4wT0lQvGArvwk9=`BsykTR"
559,1
928,0
593,
594,
595,
597,
598,
596,
800,
801,
566,0
567,","
588,","
589,"."
568,""""
570,
571,
569,0
592,0
599,1000
560,45
pCube
pFlag_Non_Unique_Dimensions
pFilter
pDimDelim
pEleStartDelim
pDim_Lookup_1
pDim_Lookup_2
pDim_Lookup_3
pDim_Lookup_4
pDim_Lookup_5
pDim_Lookup_6
pDim_Lookup_7
pDim_Lookup_8
pDim_Lookup_9
pDim_Lookup_10
pDim_Lookup_11
pDim_Lookup_12
pDim_Lookup_13
pDim_Lookup_14
pDim_Lookup_15
pDim_Lookup_16
pDim_Lookup_17
pDim_Lookup_18
pDim_Lookup_19
pDim_Lookup_20
pDim_Lookup_21
pDim_Lookup_22
pDim_Lookup_23
pDim_Lookup_24
pDim_Lookup_25
pDim_Lookup_26
pDim_Lookup_27
pDim_Lookup_28
pDim_Lookup_29
pDim_Lookup_30
pDim_Lookup_31
pDim_Lookup_32
pDim_Lookup_33
pDim_Lookup_34
pDim_Lookup_35
pDim_Lookup_36
pDim_Lookup_37
pDim_Lookup_38
pDim_Lookup_39
pDim_Lookup_40
561,45
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
590,45
pCube,""
pFlag_Non_Unique_Dimensions,"Y"
pFilter,""
pDimDelim,""
pEleStartDelim,""
pDim_Lookup_1,""
pDim_Lookup_2,""
pDim_Lookup_3,""
pDim_Lookup_4,""
pDim_Lookup_5,""
pDim_Lookup_6,""
pDim_Lookup_7,""
pDim_Lookup_8,""
pDim_Lookup_9,""
pDim_Lookup_10,""
pDim_Lookup_11,""
pDim_Lookup_12,""
pDim_Lookup_13,""
pDim_Lookup_14,""
pDim_Lookup_15,""
pDim_Lookup_16,""
pDim_Lookup_17,""
pDim_Lookup_18,""
pDim_Lookup_19,""
pDim_Lookup_20,""
pDim_Lookup_21,""
pDim_Lookup_22,""
pDim_Lookup_23,""
pDim_Lookup_24,""
pDim_Lookup_25,""
pDim_Lookup_26,""
pDim_Lookup_27,""
pDim_Lookup_28,""
pDim_Lookup_29,""
pDim_Lookup_30,""
pDim_Lookup_31,""
pDim_Lookup_32,""
pDim_Lookup_33,""
pDim_Lookup_34,""
pDim_Lookup_35,""
pDim_Lookup_36,""
pDim_Lookup_37,""
pDim_Lookup_38,""
pDim_Lookup_39,""
pDim_Lookup_40,""
637,45
pCube,"REQUIRED: Cube name ?"
pFlag_Non_Unique_Dimensions,"OPTIONAL: Flag the case when a dimension is offered more than once ?"
pFilter,"OPTIONAL: Filter or element mapping. For example: Year¦ 2020 + 2021 + 2022 & Scenario¦ Actual + Budget. Or: Dim1ToCopy¦SourceElement->TargetElement & Dim2ToCopy¦Source Element->TargetElement"
pDimDelim,"OPTIONAL: Delimiter for start of Dimension/Element set (default value if blank = '&')"
pEleStartDelim,"OPTIONAL: Delimiter for start of element list (default value if blank = '¦')"
pDim_Lookup_1,"OPTIONAL: Lookup dimension 1 (e.g. Year|Y)"
pDim_Lookup_2,"OPTIONAL: Lookup dimension 2 (e.g. Scenario|S)"
pDim_Lookup_3,"OPTIONAL: Lookup dimension 3 (e.g. Version|V)"
pDim_Lookup_4,"OPTIONAL: Lookup dimension 4"
pDim_Lookup_5,"OPTIONAL: Lookup dimension 5"
pDim_Lookup_6,"OPTIONAL: Lookup dimension 6"
pDim_Lookup_7,"OPTIONAL: Lookup dimension 7"
pDim_Lookup_8,"OPTIONAL: Lookup dimension 8"
pDim_Lookup_9,"OPTIONAL: Lookup dimension 9"
pDim_Lookup_10,"OPTIONAL: Lookup dimension 10"
pDim_Lookup_11,"OPTIONAL: Lookup dimension 11"
pDim_Lookup_12,"OPTIONAL: Lookup dimension 12"
pDim_Lookup_13,"OPTIONAL: Lookup dimension 13"
pDim_Lookup_14,"OPTIONAL: Lookup dimension 14"
pDim_Lookup_15,"OPTIONAL: Lookup dimension 15"
pDim_Lookup_16,"OPTIONAL: Lookup dimension 16"
pDim_Lookup_17,"OPTIONAL: Lookup dimension 17"
pDim_Lookup_18,"OPTIONAL: Lookup dimension 18"
pDim_Lookup_19,"OPTIONAL: Lookup dimension 19"
pDim_Lookup_20,"OPTIONAL: Lookup dimension 20"
pDim_Lookup_21,"OPTIONAL: Lookup dimension 21"
pDim_Lookup_22,"OPTIONAL: Lookup dimension 22"
pDim_Lookup_23,"OPTIONAL: Lookup dimension 23"
pDim_Lookup_24,"OPTIONAL: Lookup dimension 24"
pDim_Lookup_25,"OPTIONAL: Lookup dimension 25"
pDim_Lookup_26,"OPTIONAL: Lookup dimension 26"
pDim_Lookup_27,"OPTIONAL: Lookup dimension 27"
pDim_Lookup_28,"OPTIONAL: Lookup dimension 28"
pDim_Lookup_29,"OPTIONAL: Lookup dimension 29"
pDim_Lookup_30,"OPTIONAL: Lookup dimension 30"
pDim_Lookup_31,"OPTIONAL: Lookup dimension 31"
pDim_Lookup_32,"OPTIONAL: Lookup dimension 32"
pDim_Lookup_33,"OPTIONAL: Lookup dimension 33"
pDim_Lookup_34,"OPTIONAL: Lookup dimension 34"
pDim_Lookup_35,"OPTIONAL: Lookup dimension 35"
pDim_Lookup_36,"OPTIONAL: Lookup dimension 36"
pDim_Lookup_37,"OPTIONAL: Lookup dimension 37"
pDim_Lookup_38,"OPTIONAL: Lookup dimension 38"
pDim_Lookup_39,"OPTIONAL: Lookup dimension 39"
pDim_Lookup_40,"OPTIONAL: Lookup dimension 40"
577,0
578,0
579,0
580,0
581,0
582,0
603,0
572,450

#****Begin: Generated Statements***
#****End: Generated Statements****


#Region IntroduceThisProcess
####################################################
# Wim Gielis
# December 2022
# https://www.wimgielis.com
####################################################
#
# This process can be used to test whether dimensions exist in a cube.
# If yes, the process will pass a (concatenated) value to the calling process.
# One of the use cases of this process is to loop over cubes,
# see if cubes contain AND a year dimension, AND a scenario dimension, AND a version dimension;
# if yes, delete certain data for memory clean up purposes.
# Or, copy/paste data from a certain year-scenario-version dimension to a different combination,
# only for cubes that contain the 3 given dimensions (avoid losing data)
#
# The process is able to capture the situation where a lookup in a cube is done, with any dimension supplied more than once.
# This will lead to an error message. The use case is to make selections in a cube (for data clearing purposes) but any dimension
# can only be used once (at most).
#
# A maximum of 40 dimension names can be checked with this process.
#
# A global string variable (CubesThatContain) can also be populated with all (sorted, unique) cube names that use 1 or more of the provided dimensions/hierarchies.
#
# The latest addition to the process is code to test for Bedrock filter or element mappings.
# When passing those parameter values to a Bedrock process, it would be good to initially test for existing of dimensions in the cube.
# It could often lead to errors within Bedrock where in fact we want to avoid this situation.
#
####################################################
#
# Output (given the values in the Advanced > Parameters tab):
# |Y|S|V| if all 3 dimensions occur in the cube
# |Y|S| if only the Year and Scenario dimensions occur in the cube
# Other output: the number of dimensions in the cube
# Other output: if you for instance check only 1 dimension, the position of the dimension in the cube
#
# This format allows you to query this result, for example:
# If( Scan( '|S|', vFound_Dimensions ) > 0 );
#    then you know that the Scenario dimension occurs in the cube
# If( Scan( '|S|', vFound_Dimensions ) > 0
#   & Scan( '|V|', vFound_Dimensions ) > 0 );
#    then you know that the Scenario and Version dimensions occur in the cube
# If( Scan( '|Y|', vFound_Dimensions ) = 0 );
#    then you know that the Year dimension does not occur in the cube
# Or:
# NumericGlobalVariable( 'vAll_Dims_Found' );
# If( vAll_Dims_Found ) = 1 );    # 0 or 1
#   ...
# EndIf;.
# etc.
#
####################################################
#Region IntroduceThisProcess


#Region CallThisProcess
## call this custom process as, for instance:
If( 1 = 0 );
NumericGlobalVariable( 'vAll_Dims_Found' );
ExecuteProcess( 'WG_CUBE_lookup_dimensions_in_cube'
     , 'pCube', 'Rpt_IncomeStatement'
     , 'pFilter', ''
     , 'pDim_Lookup_1', 'Year|Y'
     , 'pDim_Lookup_2', 'Scenario|S'
     , 'pDim_Lookup_3', 'Version|V'
      );

If( vAll_Dims_Found = 1 );
   # export or copy data for this cube, for instance
EndIf;

# Or:
NumericGlobalVariable( 'vAll_Dims_Found' );
ExecuteProcess( 'WG_CUBE_lookup_dimensions_in_cube'
     , 'pCube', 'Rpt_IncomeStatement'
     , 'pFlag_Non_Unique_Dimensions', 'Y'
     , 'pFilter', 'Year¦ 2020 + 2021 + 2022 & Scenario¦ Actual + Budget. Or: Dim1ToCopy¦SourceElement->TargetElement & Dim2ToCopy¦Source Element->TargetElement'
     , 'pDimDelim', '&'
     , 'pEleStartDelim', '¦'
      );
# [pDim_Lookup_x parameters could be used too, if wanted. For instance, 'pDim_Lookup_1', 'Company']
If( vAll_Dims_Found = 1 );
   # export or copy data for this cube, for instance
EndIf;
EndIf;
#EndRegion CallThisProcess


cMax_Dims = 40;


StringGlobalVariable( 'vFound_Dimensions' );
StringGlobalVariable( 'vFound_Dimensions_Error' );
StringGlobalVariable( 'CubesThatContain' );
NumericGlobalVariable( 'vNr_Of_Dimensions' );
NumericGlobalVariable( 'vAll_Dims_Found' );
NumericGlobalVariable( 'vFound_Dimension_Position' );
vFound_Dimensions = '';
vAll_Dims_Found = 1;


If( pCube @= '' );
   vFound_Dimensions = '';
   vNr_Of_Dimensions = 0;
   vAll_Dims_Found = 0;
   vFound_Dimension_Position = 0;
   LogOutput( 'ERROR', 'The provided parameter value for the cube is empty. The process stops.');
   ProcessError;
EndIf;
   
If( CubeExists( pCube ) = 0 );
   vFound_Dimensions = '';
   vNr_Of_Dimensions = 0;
   vAll_Dims_Found = 0;
   vFound_Dimension_Position = 0;
   LogOutput( 'ERROR', 'The cube ''' | pCube | ''' does not exist. The process stops.');
   ProcessError;
EndIf;

If( CubeDimensionCountGet( pCube ) > cMax_Dims );
   vFound_Dimensions = '';
   vNr_Of_Dimensions = 0;
   vAll_Dims_Found = 0;
   vFound_Dimension_Position = 0;
   LogOutput( 'ERROR', 'The cube ''' | pCube | ''' contains ' | NumberToString( CubeDimensionCountGet( pCube )) | ' dimensions. The maximum allowed is ' | NumberToString( cMax_Dims ) | ' dimensions. The process stops.');
   ProcessError;
EndIf;

vAll_Dims_Found = 1;
vFound_Dimension_Position = 0;
sParamDim_Indexes = '';


# Does the user want to pass in Bedrock string values ?
pFilter = Trim( pFilter );
If( pFilter @<> '' );

   # parse the string and fill the 40 normal parameter values
   # but leave any dimension names that might be there already

   ## Default filter delimiters
   If( pDimDelim @= '' );
       pDimDelim = '&';
   EndIf;

   If( pEleStartDelim @= '' );
       pEleStartDelim = '¦';
   EndIf;

   If( pDimDelim @= pEleStartDelim );
       sMessage = 'The delimiters cannot be the same.';
       LogOutput( 'ERROR', sMessage );
       ProcessError;
   EndIf;

   pFilter = pFilter | pDimDelim;
   vBedrock_Filter = pFilter;

   # Determine the next open spot. t is the last index where input was done.
   t = cMax_Dims;
   While( t > 0 );
      vDim_LookUp_Param = Expand( '%pDim_LookUp_' | NumberToString( t ) | '%' );
      If( vDim_LookUp_Param @<> '' );
         # Escape the loop
         Break;
      EndIf;
      t = t - 1;
   End;

   While( 1 > 0 );

      # Search a & character
      vScan_pDimDelim = Scan( pDimDelim, vBedrock_Filter );
      If( vScan_pDimDelim > 0 );
         vDimensionAndFilter = Trim( Subst( vBedrock_Filter, 1, vScan_pDimDelim - 1 ));

         # Search a ¦ character
         vScan_pEleStartDelim = Scan( pEleStartDelim, vDimensionAndFilter );
         If( vScan_pEleStartDelim > 0 );
            vDimension = Subst( vDimensionAndFilter, 1, vScan_pEleStartDelim - 1 );
            If( DimensionExists( vDimension ) = 0 );
               sMessage = 'The Bedrock filter string seems incomplete. Dimension name ''' | vDimension | ''' does not exist.';
               LogOutput( 'ERROR', sMessage );
               # ProcessError;
               Break;
            Else;
               t = t + 1;
               If( t = 1 );
                  pDim_Lookup_1 = vDimension;
               ElseIf( t = 2 );
                  pDim_Lookup_2 = vDimension;
               ElseIf( t = 3 );
                  pDim_Lookup_3 = vDimension;
               ElseIf( t = 4 );
                  pDim_Lookup_4 = vDimension;
               ElseIf( t = 5 );
                  pDim_Lookup_5 = vDimension;
               ElseIf( t = 6 );
                  pDim_Lookup_6 = vDimension;
               ElseIf( t = 7 );
                  pDim_Lookup_7 = vDimension;
               ElseIf( t = 8 );
                  pDim_Lookup_8 = vDimension;
               ElseIf( t = 9 );
                  pDim_Lookup_9 = vDimension;
               ElseIf( t = 10 );
                  pDim_Lookup_10 = vDimension;
               ElseIf( t = 11 );
                  pDim_Lookup_11 = vDimension;
               ElseIf( t = 12 );
                  pDim_Lookup_12 = vDimension;
               ElseIf( t = 13 );
                  pDim_Lookup_13 = vDimension;
               ElseIf( t = 14 );
                  pDim_Lookup_14 = vDimension;
               ElseIf( t = 15 );
                  pDim_Lookup_15 = vDimension;
               ElseIf( t = 16 );
                  pDim_Lookup_16 = vDimension;
               ElseIf( t = 17 );
                  pDim_Lookup_17 = vDimension;
               ElseIf( t = 18 );
                  pDim_Lookup_18 = vDimension;
               ElseIf( t = 19 );
                  pDim_Lookup_19 = vDimension;
               ElseIf( t = 20 );
                  pDim_Lookup_20 = vDimension;
               ElseIf( t = 21 );
                  pDim_Lookup_21 = vDimension;
               ElseIf( t = 22 );
                  pDim_Lookup_22 = vDimension;
               ElseIf( t = 23 );
                  pDim_Lookup_23 = vDimension;
               ElseIf( t = 24 );
                  pDim_Lookup_24 = vDimension;
               ElseIf( t = 25 );
                  pDim_Lookup_25 = vDimension;
               ElseIf( t = 26 );
                  pDim_Lookup_26 = vDimension;
               ElseIf( t = 27 );
                  pDim_Lookup_27 = vDimension;
               ElseIf( t = 28 );
                  pDim_Lookup_28 = vDimension;
               ElseIf( t = 29 );
                  pDim_Lookup_29 = vDimension;
               ElseIf( t = 30 );
                  pDim_Lookup_30 = vDimension;
               ElseIf( t = 31 );
                  pDim_Lookup_31 = vDimension;
               ElseIf( t = 32 );
                  pDim_Lookup_32 = vDimension;
               ElseIf( t = 33 );
                  pDim_Lookup_33 = vDimension;
               ElseIf( t = 34 );
                  pDim_Lookup_34 = vDimension;
               ElseIf( t = 35 );
                  pDim_Lookup_35 = vDimension;
               ElseIf( t = 36 );
                  pDim_Lookup_36 = vDimension;
               ElseIf( t = 37 );
                  pDim_Lookup_37 = vDimension;
               ElseIf( t = 38 );
                  pDim_Lookup_38 = vDimension;
               ElseIf( t = 39 );
                  pDim_Lookup_39 = vDimension;
               ElseIf( t = 40 );
                  pDim_Lookup_40 = vDimension;
               Else;
                  sMessage = 'This process caters for a maximum of ' | NumberToString( cMax_Dims ) | ' dimensions. The Bedrock filter string is exceeding this limit.';
                  LogOutput( 'ERROR', sMessage );
                  # ProcessError;
               EndIf;
            EndIf;
         Else;
            sMessage = 'The Bedrock filter  ''' | pFilter | ''' string seems incomplete. Dimension delimiter  ''' | pDimDelim | ''' was found but no element delimiter ''' | pEleStartDelim | '''.';
            LogOutput( 'ERROR', sMessage );
            # ProcessError;
         EndIf;
         vBedrock_Filter = Delet( vBedrock_Filter, 1, vScan_pDimDelim );
      Else;
         Break;
      EndIf;

   End;

EndIf;

# flag it when any dimension is supplied more than once (irrespective of way of writing, take the index)
If( pFlag_Non_Unique_Dimensions @= 'Y' );

   sDim_Indexes = '';
   m = 1;
   While( m <= cMax_Dims );
      vDim_LookUp_Param = Expand( '%pDim_LookUp_' | NumberToString( m ) | '%' );

      If( vDim_LookUp_Param @<> '' );

         If( Scan( '|', vDim_LookUp_Param ) > 0 );
            vDim_LookUp = Subst( vDim_LookUp_Param, 1, Scan( '|', vDim_LookUp_Param ) - 1 );
         Else;
            vDim_LookUp = vDim_LookUp_Param;
         EndIf;

         # validate if the dimension index already occurs in the concatenated string
         If( Scan( '_' | NumberToString( Dimix( '}Dimensions', vDim_LookUp )) | '_', sDim_Indexes ) > 0 );
            vFound_Dimensions_Error = Expand( 'Dimension ''%vDim_LookUp%'' occurs more than once in the set of dimensions to be looked up.' );
            Break;
         EndIf;

         # store the dimension in a concatenated string of indexes
         sParamDim_Indexes = sParamDim_Indexes | '_' | NumberToString( Dimix( '}Dimensions', vDim_LookUp )) | '_';
      EndIf;

      m = m + 1;
   End;

   If( Long( vFound_Dimensions_Error ) > 0 );
      LogOutput( 'INFO', vFound_Dimensions_Error );
   EndIf;

EndIf;


# create the output
If( vFound_Dimensions_Error @= '' );

   # sorted, unique, cubes containing the list of dimensions
   # Populate the global string variable 'CubesThatContain'
   # Let's use a temporary dimension to get rid of duplicate cube names as well as sort the output
   v = 'CubesThatContain_' | GetProcessName | '_' | Timst( Now, '\Y\m\d\h\i\s' );
   If( DimensionExists( v ) = 0 );
       DimensionCreate( v );
       DimensionSortOrder( v, 'ByName', 'Ascending', 'ByName', 'Ascending' );
   Else;
      DimensionDeleteAllElements( v );
   EndIf;

   # Loop over the cubes
   # Followed by a loop over its dimensions
   # Followed by a loop over the provided dimensions/hierarchies
   # Match or not ?
   c = 1;
   While( c <= Dimsiz( '}Cubes' ));

      vCube = Dimnm( '}Cubes', c );

      If( Subst( vCube, 1, 1 ) @<> '}' );

         t = 1;
         While( t <= CubeDimensionCountGet( vCube ));
            tDim = Tabdim( vCube, t );

            m = 1;
            While( m <= cMax_Dims );
               vDim_LookUp_Param = Expand( '%pDim_LookUp_' | NumberToString( m ) | '%' );

               If( vDim_LookUp_Param @<> '' );

                  If( Scan( ':', vDim_LookUp_Param ) > 0 );
                     vDim_LookUp = Subst( vDim_LookUp_Param, 1, Scan( ':', vDim_LookUp_Param ) - 1 );
                  Else;
                     vDim_LookUp = vDim_LookUp_Param;
                  EndIf;

                  If( tDim @= vDim_LookUp );
                     DimensionElementInsertDirect( v, '', vCube, 'N' );

                     # Escape the loop
                     m = cMax_Dims;
                     t = CubeDimensionCountGet( vCube );
                  EndIf;
               Else;
                  # Escape the loop
                  m = cMax_Dims;
               EndIf;

               m = m + 1;
            End;

            t = t + 1;
         End;

      EndIf;

      c = c + 1;
   End;

   # What are the matching cubes, if any ?
   c = 1;
   While( c <= Dimsiz( v ));

      vCube = Dimnm( v, c );
      CubesThatContain = CubesThatContain | If( c = 1, '', pEleStartDelim ) | vCube;

      c = c + 1;
   End;

   DimensionDestroy( v );

   # the other output
   m = 1;
   While( m <= cMax_Dims );
      vDim_LookUp_Param = Expand( '%pDim_LookUp_' | NumberToString( m ) | '%' );
      vThis_Param_Is_Found = 0;

      If( vDim_LookUp_Param @<> '' );

         If( Scan( '|', vDim_LookUp_Param ) > 0 );
            vDim_LookUp = Subst( vDim_LookUp_Param, 1, Scan( '|', vDim_LookUp_Param ) - 1 );
            vResult_LookUp = Delet( vDim_LookUp_Param, 1, Long( vDim_LookUp ));
         Else;
            vDim_LookUp = vDim_LookUp_Param;
            vResult_LookUp = vDim_LookUp_Param;
         EndIf;

         # loop over dimensions to find a match
         d = 1;
         While( d <= CubeDimensionCountGet( pCube ));
            vDim = Tabdim( pCube, d );

            If( Dimix( '}Dimensions', vDim ) = Dimix( '}Dimensions', vDim_LookUp ));
               vFound_Dimensions = vFound_Dimensions | '|' | vResult_LookUp;
               vThis_Param_Is_Found = 1;
               vFound_Dimension_Position = d;
               Break;
            EndIf;

            d = d + 1;
         End;

         If( vThis_Param_Is_Found = 0 );
             vAll_Dims_Found = 0;
         EndIf;

      EndIf;

      m = m + 1;
   End;

   If( vFound_Dimensions @<> '' );
      vFound_Dimensions = Delet( vFound_Dimensions, 1, 1 );
   EndIf;

   vNr_Of_Dimensions = CubeDimensionCountGet( pCube );

EndIf;
573,3

#****Begin: Generated Statements***
#****End: Generated Statements****
574,3

#****Begin: Generated Statements***
#****End: Generated Statements****
575,2
#****Begin: Generated Statements***
#****End: Generated Statements****
576,CubeAction=1511DataAction=1503CubeLogChanges=0_ParameterConstraints=e30=
930,0
638,1
804,0
1217,1
900,
901,
902,
938,0
937,
936,
935,
934,
932,0
933,0
903,
906,
929,
907,
908,
904,0
905,0
909,0
911,
912,
913,
914,
915,
916,
917,0
918,1
919,0
920,50000
921,""
922,""
923,0
924,""
925,""
926,""
927,""
